"use strict";(self.webpackChunk_newtonschool_grauity=self.webpackChunk_newtonschool_grauity||[]).push([[603],{"./node_modules/@mdx-js/react/lib/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{R:()=>useMDXComponents,x:()=>MDXProvider});var react__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/react/index.js");const emptyComponents={},MDXContext=react__WEBPACK_IMPORTED_MODULE_0__.createContext(emptyComponents);function useMDXComponents(components){const contextComponents=react__WEBPACK_IMPORTED_MODULE_0__.useContext(MDXContext);return react__WEBPACK_IMPORTED_MODULE_0__.useMemo((function(){return"function"==typeof components?components(contextComponents):{...contextComponents,...components}}),[contextComponents,components])}function MDXProvider(properties){let allComponents;return allComponents=properties.disableParentContext?"function"==typeof properties.components?properties.components(emptyComponents):properties.components||emptyComponents:useMDXComponents(properties.components),react__WEBPACK_IMPORTED_MODULE_0__.createElement(MDXContext.Provider,{value:allComponents},properties.children)}},"./stories/migrations/v3/updateNSIconButtonV3-0-0.mdx":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{default:()=>MDXContent});__webpack_require__("./node_modules/react/index.js");var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/react/jsx-runtime.js"),_home_runner_work_grauity_grauity_node_modules_storybook_addon_docs_dist_shims_mdx_react_shim_mjs__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__("./node_modules/@mdx-js/react/lib/index.js");function _createMdxContent(props){const _components={code:"code",h1:"h1",p:"p",pre:"pre",...(0,_home_runner_work_grauity_grauity_node_modules_storybook_addon_docs_dist_shims_mdx_react_shim_mjs__WEBPACK_IMPORTED_MODULE_2__.R)(),...props.components};return(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment,{children:[(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.h1,{id:"nsiconbutton-migration-script-v300",children:"NSIconButton Migration Script (v3.0.0)"}),"\n",(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.p,{children:"This JSCodeShift script does the automated migration for NSIconButton components to v3.0.0."}),"\n",(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.pre,{children:(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_components.code,{className:"language-js",children:"const variantMapping = {\n    primary: { variant: 'primary', color: 'brand' },\n    secondary: { variant: 'primary', color: 'neutral' },\n    tertiary: { variant: 'secondary', color: 'neutral' },\n    danger: { variant: 'primary', color: 'error' },\n    success: { variant: 'primary', color: 'success' },\n    warning: { variant: 'primary', color: 'warning' },\n    'primary-outlined': { variant: 'tertiary', color: 'brand' },\n    'secondary-outlined': { variant: 'tertiary', color: 'neutral' },\n    'tertiary-outlined': { variant: 'tertiary', color: 'neutral' },\n    'danger-outlined': { variant: 'tertiary', color: 'error' },\n    'success-outlined': { variant: 'tertiary', color: 'success' },\n    'warning-outlined': { variant: 'tertiary', color: 'warning' },\n};\n\nmodule.exports = function transformer(fileInfo, api) {\n    const j = api.jscodeshift;\n    const root = j(fileInfo.source);\n\n    // Helper: process a static string value via variantMapping.\n    function getMapping(value) {\n        return variantMapping[value];\n    }\n\n    // Process JSX elements: <NSIconButton ... />\n    root.find(j.JSXOpeningElement, { name: { name: 'NSIconButton' } }).forEach(\n        (path) => {\n            const { attributes } = path.node;\n\n            // Check if a color prop is already present â†’ assume already migrated.\n            const hasColorProp = attributes.some(\n                (attr) => attr.name && attr.name.name === 'color'\n            );\n            if (hasColorProp) return;\n\n            // Find the variant attribute.\n            const variantAttribute = attributes.find(\n                (attr) => attr.name && attr.name.name === 'variant'\n            );\n            if (!variantAttribute) return; // No variant prop, so skip transformation.\n\n            // Case 1: Value is a literal string.\n            if (\n                variantAttribute.value &&\n                (variantAttribute.value.type === 'Literal' ||\n                    variantAttribute.value.type === 'StringLiteral')\n            ) {\n                const oldVariant = variantAttribute.value.value;\n                const mapping = getMapping(oldVariant);\n                if (mapping) {\n                    // Remove old prop.\n                    path.node.attributes = attributes.filter(\n                        (attr) => attr !== variantAttribute\n                    );\n                    // Add new props.\n                    path.node.attributes.push(\n                        j.jsxAttribute(\n                            j.jsxIdentifier('variant'),\n                            j.stringLiteral(mapping.variant)\n                        ),\n                        j.jsxAttribute(\n                            j.jsxIdentifier('color'),\n                            j.stringLiteral(mapping.color)\n                        )\n                    );\n                }\n            }\n            // Case 2: JSX expression container.\n            else if (\n                variantAttribute.value &&\n                variantAttribute.value.type === 'JSXExpressionContainer'\n            ) {\n                const expr = variantAttribute.value.expression;\n                // 2a. Conditional (ternary) expression.\n                if (expr.type === 'ConditionalExpression') {\n                    // Helper to extract literal string from node.\n                    function extractValue(node) {\n                        if (\n                            node.type === 'Literal' ||\n                            node.type === 'StringLiteral'\n                        ) {\n                            return node.value;\n                        } else if (\n                            node.type === 'TemplateLiteral' &&\n                            node.expressions.length === 0\n                        ) {\n                            return node.quasis[0].value.cooked;\n                        }\n                        return null;\n                    }\n                    const valueConsequent = extractValue(expr.consequent);\n                    const valueAlternate = extractValue(expr.alternate);\n                    if (valueConsequent && valueAlternate) {\n                        const mappingConsequent = getMapping(valueConsequent);\n                        const mappingAlternate = getMapping(valueAlternate);\n                        if (mappingConsequent && mappingAlternate) {\n                            // Remove old attribute.\n                            path.node.attributes = attributes.filter(\n                                (attr) => attr !== variantAttribute\n                            );\n                            // Create new conditional expressions for both props.\n                            const newVariantExpr = j.jsxExpressionContainer(\n                                j.conditionalExpression(\n                                    expr.test,\n                                    j.stringLiteral(mappingConsequent.variant),\n                                    j.stringLiteral(mappingAlternate.variant)\n                                )\n                            );\n                            const newColorExpr = j.jsxExpressionContainer(\n                                j.conditionalExpression(\n                                    expr.test,\n                                    j.stringLiteral(mappingConsequent.color),\n                                    j.stringLiteral(mappingAlternate.color)\n                                )\n                            );\n                            path.node.attributes.push(\n                                j.jsxAttribute(\n                                    j.jsxIdentifier('variant'),\n                                    newVariantExpr\n                                ),\n                                j.jsxAttribute(\n                                    j.jsxIdentifier('color'),\n                                    newColorExpr\n                                )\n                            );\n                        } else {\n                            variantAttribute.comments = (\n                                variantAttribute.comments || []\n                            ).concat([\n                                {\n                                    type: 'Line',\n                                    value: ' TODO: Manual review: variant mapping missing for one branch in conditional.',\n                                },\n                            ]);\n                        }\n                    } else {\n                        variantAttribute.comments = (\n                            variantAttribute.comments || []\n                        ).concat([\n                            {\n                                type: 'Line',\n                                value: ' TODO: Manual review: variant conditional expression not a literal.',\n                            },\n                        ]);\n                    }\n                }\n                // 2b. Template literal.\n                else if (expr.type === 'TemplateLiteral') {\n                    if (expr.expressions.length === 0) {\n                        const valueTemplate = expr.quasis[0].value.cooked;\n                        const mapping = getMapping(valueTemplate);\n                        if (mapping) {\n                            path.node.attributes = attributes.filter(\n                                (attr) => attr !== variantAttribute\n                            );\n                            path.node.attributes.push(\n                                j.jsxAttribute(\n                                    j.jsxIdentifier('variant'),\n                                    j.stringLiteral(mapping.variant)\n                                ),\n                                j.jsxAttribute(\n                                    j.jsxIdentifier('color'),\n                                    j.stringLiteral(mapping.color)\n                                )\n                            );\n                        }\n                    } else {\n                        variantAttribute.comments = (\n                            variantAttribute.comments || []\n                        ).concat([\n                            {\n                                type: 'Line',\n                                value: ' TODO: Manual review: variant template literal contains expressions.',\n                            },\n                        ]);\n                    }\n                }\n                // 2c. Any other expression.\n                else {\n                    variantAttribute.comments = (\n                        variantAttribute.comments || []\n                    ).concat([\n                        {\n                            type: 'Line',\n                            value: ' TODO: Manual review: variant prop is not a static literal or simple conditional.',\n                        },\n                    ]);\n                }\n            }\n        }\n    );\n\n    // Process styled-components inheritance: styled(NSIconButton)\n    root.find(j.CallExpression, {\n        callee: { name: 'styled' },\n        arguments: [{ name: 'NSIconButton' }],\n    }).forEach((path) => {\n        const commentText =\n            ' TODO: Manual review: NSIconButton inheritance via styled-components. Verify variant prop mapping if applicable.';\n        path.node.comments = (path.node.comments || []).concat([\n            { type: 'Line', value: commentText },\n        ]);\n    });\n\n    return root.toSource({ quote: 'single', reuseWhitespace: true });\n};\n"})})]})}function MDXContent(props={}){const{wrapper:MDXLayout}={...(0,_home_runner_work_grauity_grauity_node_modules_storybook_addon_docs_dist_shims_mdx_react_shim_mjs__WEBPACK_IMPORTED_MODULE_2__.R)(),...props.components};return MDXLayout?(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(MDXLayout,{...props,children:(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_createMdxContent,{...props})}):_createMdxContent(props)}}}]);